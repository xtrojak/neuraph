\documentclass[12pt]{article}
\usepackage[slovak]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{kpfonts}
\usepackage{hyperref}
\usepackage{amsthm}

\newcommand{\mysection}[1]{{\newpage\centering\Large\textbf{#1}\\}\normalsize\vspace{0.1cm}}
\newcommand{\mysmallsection}[1]{\vspace{0.5cm}{\centering\large\textbf{#1}\\}\normalsize\vspace{0.5cm}}

\begin{document}

\mysection{PV021 Neuronové siete \\ Záverečná správa}
\begin{center}
Adam Krupička, Matej Troják
\end{center}

\mysmallsection{Problém šachového ťahu}
V našom projekte sme chceli riešiť problém pohybu šachových figúrok po šachovnici. Napadlo nás niekoľko prístupov, ako tento problém riešiť:

\begin{enumerate}
\item dať sieti na vstup celú šachovnicu a na výstupe očakávať opäť šachovni-cu, avšak pozmenenú o jeden validný ťah,
\item dať sieti na vstup pozície jednotlivých figúrok a na výstupe očakávať pozmenené pozície figúrok,
\item dať sieti na vstup celú šachovnicu/pozície figúrok a očakávať na výstupe ťah, ktorý sa má vykonať, t.j. súradnice políčka s \textit{nejakou} figúrkou a súradnice, kam sa má posunúť,
\item dať sieti na vstup dve šachovnice a sieť odpovie hodnotou medzi 0 a 1 ako \textit{dobrý} je ťah (inšpirované iným zdrojom, neriešené)
\end{enumerate}

{\centering\textbf{Zdroj dát}\\}

Použili sme záznamy šachových partií z Games of World Champions\footnotemark[1]\footnotetext[1]{\url{http://www.chess.com/download/view/games-of-world-champions}}. Na dáta sme využili voľne dostupný parser, ktorý ich prekonvertoval do formátu FEN (Forsyth–Edwards Notation), čo je štandartná notácia pre popis priebehu šachovej partie tak, aby mohla byť opätovne zrekonštruo-vaná. \\

{\centering\textbf{Implementácia}\\}

Implementovali sme viacvrstvú sieť (multilayer perceptron) a zpätnú propagáciu (backpropagation algorithm) v jazyku C++. Implementovali sme triedy pre neurón, sieť a šachovnicu. Urobili sme serializáciu siete tak, aby sme po ukončení učenia s ňou mohli znova pracovať aj s odstupom času. Celý program má 3 rôzne funkcie:

\begin{itemize}
\item \textbf{new} - vytvorenie novej siete, parameter je \textit{"počet neurónov vo vrstvách"} a názov siete
\item \textbf{learn} - spustí učenie pomocou spätnej propagácie nad daným vstupným súborom dát a sieťou
\item \textbf{eval} - vyhodnotí sieť nad daným vstupom pre danú sieť
\end{itemize}

\mysmallsection{Prístup 1}

Vstup tvorený FENmi sme jednoduchým scriptom previedli do sekvencie 64 číslic v rozsahu hodnôt [-6, 6]. Figúrky majú nasledujúcu číselnú reprezentáciu (jedná sa o biele figúrky, čierne majú opačné znamienko):

\begin{center}
{\small
\hspace*{-1cm}\begin{tabular}{| l l | l l |}
\hline
 pešiak & 1 & strelec & 4 \\
 veža & 2 & kráľ & 5 \\
 kôň & 3 & kráľovná & 6\\
\hline
\end{tabular}
}
\end{center}

prázdne políčko má hodnotu 0.

{\centering\textbf{Riešenie}\\}

Nakoľko sme potrebovali rozsah hodnôt [-6, 6], ako aktivačnú funkciu sme zvolili hyperbolický tangens s upravenými koeficientami tak, aby bol na danom intervale približne lineárny. 

\begin{equation}
F_a(x)=12 \times tanh(\frac{x}{12})
\end{equation}

Trénovacie dáta boli dvojice sekvencií 64 číslic. Ťah je reprezentovaný tak, že na políčko, \textbf{z} ktorého sa figúrka hýbe, sa priradí číslo nula a políčko, \textbf{na} ktoré sa figúrka hýbe dostane pôvodnú hodnotu figúrky. Nakoľko v trénovacích dátach boli ťahy ako pre bieleho, tak i čierneho hráča, rozhodli sme sa používať iba biele ťahy. Tým sme dáta zmenšili o jenen rozmer (každý ťah čierneho hráča sa dá previesť na ťah bieleho hráča).

\mysmallsection{Prístup 2}

Vstup tvorený FENmi sme iným scriptom previedli do sekvencie 64 číslic v rozsahu hodnôt [0, 8]. Čísla sú vnímané ako dvojice, kde každá dvojica predstavuje súradnice konkrétnej figúrky na šachovnici. Poradie figúrok je teda fixne dané. Ak sa figúrka na šachovnici nenachádza, dostane súradnice (0, 0).

{\centering\textbf{Riešenie}\\}

Pre potrebný rozsah hodnôt sme zvolili funkciu:

\[ F_a(x) =
  \begin{cases}
    \quad 0  & \quad x \leq 0 \\
    \quad x  & \quad x > 0\\
  \end{cases}
\]

Ťah je reprezentovaný zmenou súradníc jednej figúrky. V prípade, ak sa jedná o ťah, kedy nepriateľ stráca figúrku (t.j. figúrka sa presúva na súradnice už zahrnuté v sekvencii súradníc), súradnice vyhodenej figúrky sú (0, 0).

\mysmallsection{Prístup 3}

Tento prístup je veľmi podobný prístupu číslo 2, rozdiel je iba vo výstupe siete. Namiesto toho, aby bol ťah zahrnutý v rozložení novej šachovnice, je výstupom explicitne daný ťah, t.j. súradnice políčka, \textbf{z} ktorého sa má figúrka pohnúť a súradnice \textbf{kam} sa má figúrka pohnúť.

\mysmallsection{Výsledky}

Problémom u všetkých typov prístupov bolo nájsť parametre siete tak, aby daný problém riešila. Skúšali sme mnoho kombinácii topológie siete a rýchlosti učenia, no vždy neúspešne. Pri prístupe 3, kedy funkčnosť siete vyzerala nádejne (nastavenie: 64, 128, 64, 16, 4), bol zase problém z výpočetného hľadiska. Odhad učenia bol asi tri dni a žiadny z nám prístupnych výpočetných serverov (Aisa, Aura) nepodporuje C++11 (Aisa zvláda iba c++0A.D. a Aura c++500BC). Preto sme nemali ako otestovať, či je sieť schopná sa tomuto prístupu naučiť. 

Preto sme rozhodli riešiť pomocou neurónových sieti iný problém.

\newpage
\mysmallsection{Problém derivácie polynómu}

Ideou je, že sa sieti na vstup dá polynóm a ona vráti jeho deriváciu. 

{\vspace*{0.5cm}\centering\textbf{Príklad}\\}

Majme vstupný polynóm:

\begin{equation}
f(x)=5x^3 + 2x + 8
\end{equation}

Takýto polynóm bude v skutočnosti interpretovaný pre sieť nasledovne (uvažujme, že sieť je schopná načítavať polynómy stupňa maximálne 5):

\begin{equation}
f(x)=0x^5 + 0x^4 + 5x^3 + 0x^2 + 2x^1 + 8x^0
\end{equation}

\noindent takže finálnym vstupom pre sieť je sekvencia čísel "\textbf{0 0 5 0 2 8}".

Chceme dostať deriváciu tohto polynómu

\begin{equation}
f'(x)=15x^2 + 2
\end{equation}

\noindent čiže sekvenciu čísel "\textbf{0 0 15 0 2}", ktorá je o jednu číslicu kratšia.

{\centering\textbf{Zdroj dát}\\}

Ako zdroj dát sme zvolili funkciu, ktorá vygeneruje náhodný polynón z daného rozsahu hodnôt (maximálny stupeň polynómu a rozsah koeficientov) a zároveň vypočíta jeho deriváciu. 

{\vspace*{0.5cm}\centering\textbf{Riešenie}\\}

Nakoľko rozsah koeficientov, ktoré môžu byť v polynóme použité je z všeobecného hľadiska neobmedzený, rozhodli sme sa použiť lineárnu funkciu: 

\begin{equation}
F_a(x)=x~,
\end{equation}

\noindent ktorá má v každom bode deriváciu rovnú 1.  

\mysmallsection{Výsledky}

Prvým pokusom bolo realizovať derivovanie pomocou neurónovej siete na veľmi obmedzených polynómoch. Zvoli sme maximálny stupeň polynómu 3 a rozsah koeficientov ako [0, 3]. Topológiu siete sme zvolili "3~81~2". Problém bol v rýchlosti učenia, ktorú sme museli nastaviť na veľmi malú hodnotu, aby sa sieť správne učila -- 0.0001.

Následne po dostatočnom učení (asi 20000 náhodne vygenerovaných polynómov) sme dosiahli pozitívne výsledky vo výstupoch siete. Tu je niekoľko príkladov:

\begin{itemize}
\item \begin{tabular}{ l l }
		vstup: & $2 + 1x^1 + 3x^2$\\
		derivácia: & $1.05352 + 5.89288x^1 $
	  \end{tabular}
\item \begin{tabular}{ l l }
		vstup: & $2 + 1x^1$\\
		derivácia: & $1.00556 + 0.129582x^1$
	  \end{tabular}
\item \begin{tabular}{ l l }
		vstup: & $3 + 3x^1 + 3x^2$\\
		derivácia: & $2.93755 + 5.82714x^1$
	  \end{tabular}
\end{itemize}

Druhým výsledkom je iný prístup k učeniu. Namiesto toho, aby sme sieť učili konkrétne polynómy, dávali sme jej na vstup vždy iba jeden člen s nenulovým koeficientom. Tým sme chceli dosiahnuť \textit{nezávislosť} jednotlivých členov medzi sebou. 

\end{document}